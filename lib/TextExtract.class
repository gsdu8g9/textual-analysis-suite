<?php

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Description of TextExtract
 *
 * @author peter
 */
class TextExtract {
    //put your code here

    /**
     * Basic function to take a line of text and convert it into a basic array of words.
     * 
     * @param type $line
     * @return type
     */
    static public function makeWords($line)
    {
        $words = explode(' ', $line);

        return $words;
    }

    /**
     * 
     * Only return the capital letters on the provided string
     * 
     * @param string $line
     * @return string type
     */
    public static function capitals($line)
    {
        return preg_replace('/[^A-Z]/', '', $line);
    }

    /**
     * 
     * Find all the first letters of words in the provided string.
     * 
     * Optionally return the whole lot as a capitalized string
     * 
     * @param string $line
     * @param boolean $cap
     * @return string
     */
    public static function firstLetters($line, $cap = true)
    {

        $array = array();

        preg_match_all("/(\S)\S*/i", $line, $array, PREG_PATTERN_ORDER);

        $return = '';

        if (isset($array[1]))
        {
            $return = implode('', $array[1]);
        }

        if ($cap)
        {
            $return = strtoupper($return); // sometimes we want to capitalize the string to simplification
        }
        return $return;
    }

  
    /**
     * A simple function to test for brackets nicely, as they were causing problems in the original system
     * 
     * 
     * @param type $chr
     * @return boolean
     */
    public static function removeParens($chr)
    {
        if ($chr == '[' or $chr == ']')
        {
            return false;
        }

        if ($chr == '(' or $chr == ')')
        {
            return false;
        }

        return true;
    }
    
    
    public static function characterFrequency($string, $keep_case = true, $include_space = false, $include_punction = false)
    {
        $count_array = self::characterCountDetails($string);
        $second_array = array(); // saves getting lost - not memory ideal though
        
        
        // now we need to process it
        
        if( $keep_caps == false )
        {
            foreach($count_array as $_chr => $_cnt)
            {
                if( ! isset($second_array[strtoupper($_chr)]))
                {
                    $second_array[strtoupper($_chr)] = 0;
                }
                
                $second_array[strtoupper($_chr)] = $second_array[strtoupper($_chr)] + $_cnt;
            }
        }
        else
        {
            $second_array = $count_array;
        }
        
    }
    
    
    /**
     * 
     * 
     * give the full character count of a string
     * 
     * @param string $string
     * @return array
     */
    public static function characterCountDetails($string)
    {
        $count_array = self::count_chars_unicode($string, true);
        
        return $count_array;
    }
    
    
    /**
     * 
     * just return the actual character count without any details, i,e: unique characters.
     * 
     * @param type $string
     * @return int
     */
    public static function characterCount($string)
    {
       return self::count_chars_unicode($string, false);
    }
    
    
    
    
    // ------------------------------------------------------------------------------------------------------------------------------------
    // ------------------------------------------------------------------------------------------------------------------------------------
    //
    // Some general utility functions for now.
    //
    // ------------------------------------------------------------------------------------------------------------------------------------
    // ------------------------------------------------------------------------------------------------------------------------------------
    
    /**
     * 
     * same as char_count but handles unicode.
     * 
     * @param type $str
     * @param type $x
     * @return type
     */
    public static function count_chars_unicode($str, $x = false)
    {
        $tmp = preg_split('//u', $str, -1, PREG_SPLIT_NO_EMPTY);
        foreach ($tmp as $c)
        {
            $chr[$c] = isset($chr[$c]) ? $chr[$c] + 1 : 1;
        }
        return is_bool($x) ? ($x ? $chr : count($chr)) : $chr[$x];
    }

    

    /**
     *
     * http://practicalcryptography.com/cryptanalysis/text-characterisation/index-coincidence/
     *
     * The index of coincidence is a measure of how similar a frequency distribution is to the uniform distribution. 
     * The I.C. of a piece of text does not change if the text is enciphered with a substitution cipher. It is defined as: 
     *
     *
     */
    function indexOfincidenceCoincidence($string)
    {
      $string = strtolower($string);

      $string = preg_replace('/[^a-zA-Z]/', '', $string);

      $text = preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY);
      
      $alpha = 26;

      $counts = array();
      $totcount = 0;

      for($i = 0; $i < $alpha ; $i++)
	{
	  $counts[$i] = 0;
	}

      foreach($text as $char)
	{
	  $counts[ord($char) - 97]++;
	  $totcount++;
	} 


      $sum = 0;

      for($i = 0; $i < $alpha; $i++)
	{
	  $sum = $sum + $counts[$i] * ($counts[$i] -1 );
	}

      $ic = $sum / ($totcount * ($totcount -1 ));

      return $ic;

    }


    /**


     */
    function chiSquared($string)
    {

      $expected = array( 0.08167,0.01492,0.02782,0.04253,0.12702,0.02228,0.02015,0.06094,0.06966,0.00153,0.00772,
			 0.04025,0.02406,0.06749,0.07507,0.01929,0.00095,0.05987,0.06327,0.09056,0.02758,0.00978,
			 0.02360,0.00150,0.01974,0.00074);

      $string = strtolower($string);

      $string = preg_replace('/[^a-zA-Z]/', '', $string);

      $text = preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY);
      
      $alpha = 26;

      $counts = array();
      $totcount = 0;

      for($i = 0; $i < $alpha ; $i++)
	{
	  $counts[$i] = 0;
	}

      $sum1 = 0.0;

      foreach($text as $char)
	{
	  $counts[ord($char) - 97]++;
	  $totcount++;
	} 

      for($i = 0; $i < $alpha ; $i++)
	{
	  $sum1 = $sum1 + pow($counts[$i] - $totcount * $expected[$i], 2) / ( $totcount * $expected[$i]);
	}

      $sum2 = 0.0;

      for($i = 0; $i < $alpha ; $i++)
	{
	  $sum2 = $sum2 + pow($counts[$i] - $totcount / 26, 2) / ( $totcount / 26);
	}

      

      $return = array();

      $return['statistic'] = $sum1;
      $return['uniform']  = $sum2;

      return $return;

    }

}

